These are some basic rough definitions for the objects used in the optimization routines.

A lot of these have been over-engineered and have since been dialed down considerably.  
For accurate information, please see the source code.  It's structured almost the same
as this page



## Base objects
### Customer
Basic structure of a customer as defined by the Solomon Problem sets

### Vehicle
Basic concept of the vehicle.  Tracks visited customers, current time, current capacity.

Vehicle supplies functions that help check whether we can add to the list, 
and to find feasible customers.

isFeasible, travelTime, travelDist, geographicCenter, serveCustomer, last.

### Dispatch
Coordinates customers and vehicles. Decides which customers the vehicles serve and when
to add new vehicles.  

A dispatch is implicitly (*TODO build this into the code*) considered `complete` when
all of it's customers have been served (assigned to a vehicle). 
An incomplete or empty dispatch is the input of both the heuristic
and roll out algorithms where a complete dispatch is the output of both algorithms.

### Parameters
Singleton object that captures the input parameters of the problem and some metaparameters
that are used for calculating the problem.  Much of these parameters should be explicitly 
captured in the various other objects, but a handful of pseudo-global 
variables greatly eases development and prototyping.

### SolomonProblem
Basic problem definition of the Solomon Problem set. Used to define the customers and basic
hyperparameters for the problem.

## Algorithms
The algorithms directory contains many objects that describe the main algorithms and 
functions used in the solution. For some of these functions, there was no clear
place to go within an object, so they have found their home here, usually exposed
as static methods.

The four main algorithms will each be featured here: Heuristic(1), RollOut(2), 
Improvement(3), and WindowMods(4).

Each of the main for algorithms will come equiped with a main method for both debugging
and demoing purposes.

### Heuristic
Algorithm for building part 1 of the ICRI paper. 

The rollout uses this heuristic algorithm for the `rolling out` aspect of the algorithm.
This should have a very uniform interface so that switching heuristics is very simple.

(*TODO  Should there be two different cost functions, one for the bestSequence in 
the roll out, and another for the heursistic?*)


### RollOut
Algorithm for building part 2 of the ICRI paper. 

A point of note for this algorithm is the use of copying objects.  The basic premise is
to copy the dispatch solution, rollout the heuristic on this solution, and if it's good, 
save it.

### Improvement
Algorithm for building part 3 of the ICRI paper.

### Validator
Helper object that consumes a routes object and confirms that it abides by all our rules.

### Cost
Defines multiple different cost functions for defining best next nodes and cost of routes.

These main cost functions are: 
* Cost.ofSolution - Cost of a solution generated by the heuristic 
* Cost.gnnh - Generalized cost used by the heuristic.


